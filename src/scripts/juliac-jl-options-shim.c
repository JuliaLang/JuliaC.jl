/*
 * JuliaC jl_options constructor shim.
 *
 * Sets jl_options fields before jl_init via __attribute__((constructor)).
 *
 * On macOS, dlsym with a handle from dlopen searches that image and its
 * dependencies, so we use dladdr/dlopen/dlsym to resolve jl_options from
 * our own libjulia dependency.
 *
 * On Linux, dlopen(RTLD_NOLOAD) on the main executable returns NULL, so
 * we use RTLD_DEFAULT which searches all loaded shared objects. This is
 * safe because our libjulia is the only one loaded at constructor time.
 *
 * On Windows, DLL import resolution is per-module, so &jl_options already
 * resolves to the correct instance from our libjulia dependency.
 *
 * The actual option assignments are generated by JuliaC and included via
 * "juliac-jl-options-body.h".
 */

#define _GNU_SOURCE

#include <julia.h>
#include <stdlib.h>

#ifdef _WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif

__attribute__((constructor))
static void juliac_set_jl_options(void) {
#ifdef _WIN32
    jl_options_t *opts = &jl_options;
#elif defined(__APPLE__)
    Dl_info info;
    if (!dladdr((void *)&juliac_set_jl_options, &info)) return;
    void *self = dlopen(info.dli_fname, RTLD_NOLOAD | RTLD_NOW);
    if (!self) return;
    jl_options_t *opts = (jl_options_t *)dlsym(self, "jl_options");
    dlclose(self);
    if (!opts) return;
#else
    /* Linux: RTLD_DEFAULT searches all loaded shared objects */
    jl_options_t *opts = (jl_options_t *)dlsym(RTLD_DEFAULT, "jl_options");
    if (!opts) return;
#endif

    /* Generated option assignments */
#include "juliac-jl-options-body.h"
}
